\documentclass{report}
\usepackage{float}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{graphicx,wrapfig,lipsum}
\usepackage{geometry}
\usepackage{minted}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{csquotes}
\usepackage{dirtree}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{makecell}
\usepackage{array}
\usepackage[toc,page]{appendix}
\usepackage[backend=biber,style=ieee]{biblatex}
\addbibresource{main.bib}
\geometry{top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm}

\lstdefinelanguage{typescript}{
  keywords={class, constructor, function, return, if, else, let, const, var, export, import, extends, implements, private, public, protected, static, readonly, async, await, new, try, catch, throw},
  sensitive=true,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]{"},
  morestring=[b]`,
  keywordstyle=\color{blue}\bfseries,
  identifierstyle=\color{black},
  stringstyle=\color{red},
  commentstyle=\color{gray}\itshape,
  morekeywords={type, interface, from, of},
}


% -------------------------------------------------------
% Titelseiten-Informationen (Diese Abändern)
% -------------------------------------------------------
\title{Erstellung einer Todo App mit React und AWS CDK}

% Art der Arbeit + Studiengang
\newcommand{\arbeitstyp}{Beleg}
% Modul / Lehrveranstaltung + Dozent:innen
\newcommand{\modul}{Modul / Lehrveranstaltung: Web Engineering 3\\
Dozent: Christopher Hilgner}
% Hochschule + Fakultät
\newcommand{\hochschule}{
\includegraphics[height=2.5cm]{LOGO_HSZG_SUBLINE_GRANIT.png}\\[5mm]
Hochschule Zittau/Görlitz \\ Fakultät Elektrotechnik und Informatik
}

% Autor
\author{
    Niklas Kaulfers \\[2mm]
    Matrikelnummer: 1064032
}
% Betreuer (für BA-Thesis, sonst leer lassen)
\newcommand{\betreuer}{}

% Datum der Abgabe
\date{Abgabedatum: \today}

% -------------------------------------------------------
% Titelseite neu definieren
% -------------------------------------------------------
\makeatletter
\renewcommand{\maketitle}{
    \begin{titlepage}
        \centering
        {\Large \hochschule\par}
        \vfill

        {\huge \bfseries \@title\par}
        \vspace{1cm}

        {\large \arbeitstyp\par}
        \vspace{0.5cm}

        {\large \modul\par}
        \vspace{0.5cm}

        {\large \betreuer\par}
        \vspace{1.5cm}

        {\Large \@author\par}
        \vspace{2cm}

        {\large \@date\par}

        \vfill
    \end{titlepage}
}
\makeatother


\fancypagestyle{plain}{%
    \fancyhead[C]{%
        \includegraphics[height=1.25cm]{LOGO_HSZG_SUBLINE_GRANIT_ICON_ONLY.png}%
    }
    \fancyfoot[L]{\sffamily Kaulfers}
    \fancyfoot[C]{\sffamily \arbeitstyp\ WE3}
    \fancyfoot[R]{\sffamily\thepage}
    \renewcommand{\footrulewidth}{0.4pt}
}

\begin{document}

\pagestyle{plain}
\pagenumbering{gobble}
\setlength{\headheight}{47pt}

\maketitle
\tableofcontents
\pagenumbering{roman}
\chapter{Einleitung}
\pagenumbering{arabic}
    Ein durchaus häufig erstelltes Projekt in der Softwareentwicklung ist eine Todo-App.
    Anhand solcher können grundlegende Kenntnisse der Entwickler zur jeweiligen Umgebung gezeigt werden.
    Im Verlauf dieser Arbeit wird der Entwicklungsprozess einer solchen App im Serverless Kontext mit einem React Frontend erläutert.\\
    Hierzu entstehen Einblicke in den technischen Aufbau der Anwendung.
    Auch die genaue Komposition der Endpunkte und einige Codeabschnitte werden betrachtet.
\section{Serverless}
    Um den genauen Aufbau dieser Anwendung zu verstehen, muss der Leser vorkenntnisse im Bereich des \textit{Cloud Computings} und \textit{Serverless} haben. 
    Serverless bezieht sich auf Softwareanwendungen, welche in der Cloud veröffentlicht werden, der Entwickler sich jedoch nicht um den tieferen Aufbau des Servers kümmern muss.
    So ist der Begriff Serverless durchaus irreführend.
    Server existieren, werden jedoch von dem Cloud-Anbieter, in diesem Fall AWS, verwaltet.
    Viele Service wie AWS Lambda oder AWS DynamoDB fallen in die Kategorie von Serverless.

\chapter{Tech Stack}
    Das Backend besteht vollständig aus AWS Services.
    Um genau zu sein ApiGateway, Lambda, DynamoDB und Cognito.
    Diese haben jeweils eigene Aufgaben.
    So ist ApiGateway verantwortlich dafür, eine RestAPI zur Verfügung zu stellen.
    Alle Endpunkte der Anwendung sind innerhalb dieser API zu finden.
    Der Service Cognito schützt die Endpunkte, in dem er nur verifizierten Nutzern den Zugriff auf die API gestattet.
    Ohne Verifizierung hat der Nutzer des Frontends keinen Zugriff auf die API Endpunkte.
    Lambdas stellen Funktionen im Serverless Kontext da.
    In diesen kann die Logik der Anwendung mit eigenem Code definiert werden.
    Innerhalb der hier behandelten Anwendung wird die gesamte Logik in Typescript und mittels Nodejs geschrieben.
    Für Persistenz sorgt DynamoDB, die NoSQL Datenbank von AWS.\@
\section{Frontend}
    Um mit dem Backend zu interagieren wird ein React Frontend verwendet.
    Eine solche SPA besteht aus mehreren Komponenten, welche individuell, voneinander unabhängig ausgeführt werden können.
    Dieses nutzt für Styling \textit{Tailwind CSS} und \textit{MUI}.\@
    Für Nutzerverifizierung im Frontend wird \textit{react OIDC} genutzt.
    MUI hingegen ist eine Komponenten Bibliothek für React. 
    Zusammen sorgen MUI und Tailwind für ein anschauliches Erscheinungsbild.\\
    Für Nutzerverifizierung im Frontend wird \textit{react OIDC} genutzt.
    Gemeinsam mit einem von AWS bereitgestellten Login-Bildschirm sorgt diese Bibliothek für eine Absicherung der Anwendung.
\section{Entwicklungsumgebung}
    Die gesamte Anwendung wurde im Umfeld von \textit{IntelliJ IDEA} erstellt.
    Als Programmiersprache wird ausschließlich \textit{Typescript} verwendet, für Frontend, Backend und Infrastruktur.
    Um die Anwendung ordentlich zur Verfügung zu stellen wird das Backend über AWS CDK erstellt.
    Dies ist ein Infrastructure as Code (IaC) Tool für AWS.\@
    In AWS CDK kann ein \textit{Cloudformation Stack} mittels einer Programmiersprache definiert werden.
    Dieser Stack stellt ein Abbild der zu erwartenden Infrastruktur innerhalb der AWS Cloud da.
    Mittels dieses Stacks werden die einzelnen Serverless Service miteinander verknüpft.
    Auch werden hier Zugriffsrechte mit AWS IAM definiert.

\chapter{Aufbau und Architektur}
    Die Anwendung stellt eine Todo-App da.
    In dieser kann ein Nutzer eigene Todos erstellen.
    Ein Todo besteht aus einem Titel, einer Beschreibung, einem Boolean-Wert und einer eindeutigen ID.\@
    Zudem einen Verweis auf in welche Listen sich dieses Todo befindet.
    Auch die Listen haben einen Verweis auf alle Todos, welche sich in dieser Liste befinden.
    Listen und Todos haben Methoden, um diese mit neuen Werten zu überschreiben.
    Auch besteht die Möglichkeit sie zu löschen.
    Die Entwicklung fand in zwei eigenständigen Projekten statt – dem Backend und dem Frontend.
    Das liegt daran, dass es sich bei der Datenbank nicht um eine relationale Datenbank handelt.
    Entsprechende Logik zu den Relationen muss somit in der Logik eingebaut werden.
\chapter{Implementierung}
    Die Entwicklung fand in zwei alleinstehenden Projekten statt -- dem Backend und dem Frontend.
    Vor allem von Bedeutung ist das Backend.
    Dort wird die Logik definiert.
    Das Backend besteht aus einem AWS CDK Projekt.
    In diesem werden verschiedene \textit{Constructs} verwendet.
    Ein Construct definiert den Rahmen in welchem eine Komponente verwendet wird und ermöglicht so Objektorientiert Programmierung (OOP).
    Das untenstehende Construct für ApiGateway ist ein in diesem Projekt verwendetes L3 Construct, in dem die verschiedenen Endpunkte, Definitionen für SwaggerIO und Integrationen (Integrations) definiert sind.\\
    So hat ApiGateway ohne IAM Rollen nicht die nötigen Rechte, um die Lambdafunktion mit der entsprechenden Logik auszuführen.
    Die grundlegende Version sind L1 Constructs, diese stellen eins zu eins ein Abbild der Konfiguration für Cloudformation da.
    Hingegen sind L2 Ressourcen bereits angepasst von AWS, um sinnvoll und ohne zu viel Arbeit verwendet werden zu können.
    Mit L3 Ressourcen werden mehrere Ressourcen erstellt, welche sinnvoll miteinander interagieren\footfullcite{aws_cdk_constructs}.
    Das untenstehende Construct für ApiGateway ist ein in diesem Projekt verwendetes L3 Construct, in dem die verschiedenen Endpunkte, Definitionen für SwaggerIO und Integrationen definiert sind.\\
    Auch werden in diesen Constructs die Trust-Relationen erstellt.
    Diese werden vom Service IAM genutzt, um Servicen Zugriff zu anderen Servicen zu erlauben.
    So hat ApiGateway ohne IAM Rollen nicht die nötigen Recht, um die Lambdafunktion mit der Entsprechenden Logik auszuführen.
    \begin{figure}[!h]
        \begin{lstlisting}[language=typescript, numbers=left, frame=single, basicstyle=\small\ttfamily]
export class ApiGatewayConstruct extends Construct {
    private readonly props: ApiGatewayProps;
    private readonly _restApi: RestApi;

    constructor(scope: Construct, id: string, props: ApiGatewayProps) {
        super(scope, id);
        this.props = props;
        // ...
    }
}
        \end{lstlisting}
        \caption{Beispiel eines L3 Constructs aus dem Projekt}       
    \end{figure}\\
    Viele dieser Constructs stellt AWS selber zur Verfügung, jedoch kann der Nutzer eigene erstellen. 
    Dies geschieht, indem eine Klasse mit der Klasse \textit{Construct} erweitert wird.
    Da die gesamte Logik auf Lambda-Funktionen basiert, erfolgen Lambda-Integrationen.
    So sind zusammenhänge besser ersichtlich, falls es während des Deploys zu einem Error kommt.
    Als Error wird in der Konsole das verantwortliche Construct ausgegeben.
    Auch in der AWS Konsole (dem GUI von AWS) kann auf der Seite von Cloudformation das Construct mit dem Error genauer betrachtet werden.
    Dort ist von AWS auch ein vermutlicher \textit{root cause} angegeben.

\section{Endpunkte}
    Alle Funktionen dieser Anwendung sind mit eigenen Endpunkten im Backend ausführbar.
    Da die gesamte Logik auf Lambdafunktionen basiert erfolgen Lambdaintegrationen.
    Mittels dieser kann der Rückgabewert der Lambdafunktion direkt als Rückgabewert des Api-Endpunkts verwendet werden.
    Ein öffentlich ausführbarer Endpunkt muss innerhalb von AWS als eine \textit{Stage} erstellt werden.
    Erst dann kann er über eine URL aufgerufen werden.
    Innerhalb des Codes ist dies durch das Construct \textit{Deployment} geregelt.
    Es bestehen Endpunkte für alle CRUD-Funktionen für die Listen- und die To-Do-Tabelle.
    Alle Kommunikation mit diesem Endpunkt gelingt nun über \texttt{Basis-URL + '/prod'}.
    Mittels \textit{Model} werden die erlaubten Rückgabewerte und die Dokumentation definiert.
    Diese kann anschließend innerhalb der AWS-Konsole als SwaggerIO JSON exportiert werden.
    Eine solche Datei liegt in der Root des Projekts.
    Dieses erlaubt Bundling von Code und Runtime-Definitionen.
    Um best practices zu Folgen ist Cors aktiviert. 
    Zugriff auf die API kann von http://localhost:5173 und der Frontend-URL erfolgen.
    Alle Endpunkte sind zudem mittels eines \textit{Cognito Authorizers} geschützt.\\
    Es bestehen Endpunkte für alle CRUD-Funktionen für die Listen- und die Todotabelle.
    Einzelne Todos und Listen können über ein \textit{POST-Request} über die Endpunkte /ToDo und /List erstellt werden.
    Für \textit{UPDATE}, \textit{DELETE} und \textit{GET} wird die id des Todos oder der Liste als \textit{path parameter} benötigt.
    Auch besteht mit dem /addToList-Endpunkt eine Methode um ein Todo einer Liste hinzuzufügen.
    Eine Vielzahl an \textit{OPTIONS}-Schnittstellen existieren für Cors-Preflight.
\section{Logik}
    Zum publishen von Lambdafunktionen, welche die Logik beinhalten, wird das Construct \textit{NodeJsFunktion} genutzt.
    Dieses erlaubt bundeling von Code und Runtime-Definitionen.
    Auch besteht die Möglichkeit eine NodeJsFunktion direkt mit Typescript in Aws zu integrieren, hierbei kann die Kompilierung sowohl mittels Ressourcen in der Cloud, als auch lokal, ausgeführt werden.
    Im Gegensatz dazu muss in diesem Projekt nach einer Abänderung der Lambdafunktion diese manuell kompiliert werden.
    Die Funktionen erhalten eine Rolle mit sehr großzügigen Rechten, diese müssen im Entwicklungsverlauf noch beschränkt werden.\\
    Die Logik ist auch für entsprechende Datenbankoperationen zuständig.
    Grund hierfür ist die NoSQL Datenbank DynamoDB.\@
    Um beim DELETE eines Todos dieses aus allen Listen zu entfernen muss eine Transaktion erfolgen, welche das Todo aus dem Todo-Table löscht und in dem List-Table alle Listen durchgeht, in welchen das Todo sich befindet, um die Referenz aus diesen zu löschen.
    Dieser Authorizer überprüft das JWT-Token aus dem Header und stellt fest, dass der Nutzer ein angemeldeter Nutzer aus dem Benutzerpool ist.
    Der genauere Ablauf ist anhand eines Beispiels am verständlichsten.
    In der Funktion wird eine Transaktion mittels des AWS Software Development Kits (SDK) für DynamoDB erstellt.
    Das Szenario stellt hier bereit, dass der Nutzer angemeldet ist und sowohl ein Todo, als auch eine Liste, vorhanden sind.
    Nun möchte der Nutzer das Todo in eine Liste einfügen.
    Dazu klickt er im Frontend auf den entsprechenden Button.
    Erstellt wird ein Post-Request auf /ToDo/addToList mit einem Body und einem Header.
    Im Header befindet sich ein JWT-Token als Authorization, während im Body die Id der Liste und die Id des Todos gelistet sind.
    Der Request wird zuerst mittels Cors geprüft über ein Options-Request, ob die Origin-Adresse valide ist.
    Hier ist sie es.
    Anschließend wird der tatsächliche Post-Request an ApiGateway übergeben.
    An diesem ApiGateway ist ein Authorizer des Services Cognito angebracht.
    Dieser Authorizer überprüft das JWT-Token aus dem Header und stellt fest, dass der Nutzer ein angemeldeter Nutzer aus dem Userpool ist.
    Daraufhin triggered ApiGateway seine integrierte Lambdafunktion an diesem Endpunkt.
    Die Funktion liest den Body aus und stellt fest, dass beide Werte richtig übergeben wurden.
    In der Funktion wird eine Transaktion mittels des AWS Softwaredevelopmentkits (SDK) für DynamoDB erstellt.
    Darin werden die Ids in die entsprechenden Todos und Listen als Abhängigkeit eingetragen.
    Nachdem dies erfolgreich geschah wird von der Lambdafunktion eine Erfolgsnachricht zurückgegeben.
    Da die Lambdafunktion eine Lambdaintegration hat, wird das Resultat der Funktion so über ApiGateway an das Frontend weitergegeben, ohne noch einmal von ApiGateway überarbeitet zu werden.
    Das ist der Grund dafür, dass die Lambdas Headers mit Cors im Rückgabewert haben. 
\begin{figure}[!h]
    \includegraphics[height=10cm]{ToDoAppArchitektur.drawio.png}\label{gph:attach}
    \caption{Ablauf des Hinzufügens eines Todos zu einer Liste}
\end{figure}
\section{Tests}
    In dem Projekt existieren eine Vielzahl an verschiedenen Tests.
    Dazu gehören Unittests und Integrationstests auf Lambda-Ebene, Integrationstests auf CDK-Ebene (mit verschiedenen Tools) und Snapshottests.
    Leider sind nur die Unittests und Integrationstests auf Lambda-Ebene aktuell funktionsfähig.
    Bei diesen handelt es sich um Tests mit dem JS-Testframework Jest.
    Die Tests überprüfen, ob eine Todo richtig geupdatet wird.
    Sprich den Fall eines Put-Requests auf den Endpunkt \texttt{/Todo/\{id\}} mit einer entsprechenden Id.
    Auch gibt es Tests für Post auf ein neues Todo.

\section{Frontend}



\chapter{Building}
    Da das Projekt für AWS ausgelegt ist, ist lokales Building nicht empfehlenswert.
    Was ist benötigt, um dieses Projekt zu nutzen?\\
    Ein AWS Account mit CLI-Zugriff.
    Diesen kann man auf der Webseite von AWS erstellen.
    Jedoch gelangt man vorerst in den Root-Account.
    Es ist zu empfehlen, einen Nutzeraccount beim Service IAM zu erstellen.
    Über diesen besteht die Möglichkeit, Access-Token für die CLI zu kreieren.
    Mittels des Tokens kann über das \textit{AWS CLI Tool} (download via npm) Zugriff auf AWS Ressourcen erstellt werden.\\
    Da mit AWS CDK gearbeitet wird muss auch dieses als CLI Tool installiert werden.
    Das Kommando \textit{cdk deploy} kann anschließend genutzt werden, um den Stack auf AWS zu deployen.\\
    Das Frontend kann ohne ein eigenes Backend verwendet werden.
    Hierfür müssen die Environment-Variablen gesetzt werden.
    Diese sind: \texttt{VITE\_API\_URL} und \texttt{VITE\_REDIRECT\_URL}.
    Mit \textit{npm run dev} wird eine lokale Instanz erstellt, welche mit dem Backend kommunizieren kann.
\chapter{Fazit}

\printbibliography\end{document}